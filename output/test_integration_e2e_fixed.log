============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.0, pluggy-1.6.0 -- /usr/bin/python3.12
cachedir: .pytest_cache
rootdir: /home/seth/wildfire-watch
plugins: cov-6.1.1, timeout-2.4.0, mock-3.14.1, asyncio-1.0.0, anyio-4.4.0
timeout: 300.0s
timeout method: signal
timeout func_only: False
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 5 items

tests/test_integration_e2e.py::TestE2EIntegration::test_service_startup_order ERROR [ 20%]
tests/test_integration_e2e.py::TestE2EIntegration::test_camera_discovery_to_frigate ERROR [ 40%]
tests/test_integration_e2e.py::TestE2EIntegration::test_fire_detection_to_pump_activation ERROR [ 60%]
tests/test_integration_e2e.py::TestE2EIntegration::test_health_monitoring ERROR [ 80%]
tests/test_integration_e2e.py::TestE2EIntegration::test_error_recovery ERROR [100%]

==================================== ERRORS ====================================
_______ ERROR at setup of TestE2EIntegration.test_service_startup_order ________

self = <docker.api.client.APIClient object at 0x7f9acfd8e480>
response = <Response [404]>

    def _raise_for_status(self, response):
        """Raises stored :class:`APIError`, if one occurred."""
        try:
>           response.raise_for_status()

../.local/lib/python3.12/site-packages/docker/api/client.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ""
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode("utf-8")
            except UnicodeDecodeError:
                reason = self.reason.decode("iso-8859-1")
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = (
                f"{self.status_code} Client Error: {reason} for url: {self.url}"
            )
    
        elif 500 <= self.status_code < 600:
            http_error_msg = (
                f"{self.status_code} Server Error: {reason} for url: {self.url}"
            )
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json

/usr/local/lib/python3.12/dist-packages/requests/models.py:1024: HTTPError

The above exception was the direct cause of the following exception:

self = <integration_setup.IntegrationTestSetup object at 0x7f9acfd8e420>

    def setup_gpio_trigger(self):
        """Create GPIO trigger container"""
        mqtt_container = self.setup_mqtt_broker()
    
        try:
>           image = self.docker_client.images.get("wildfire-watch/gpio_trigger:test")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration_setup.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.local/lib/python3.12/site-packages/docker/models/images.py:333: in get
    return self.prepare_model(self.client.api.inspect_image(name))
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/utils/decorators.py:19: in wrapped
    return f(self, resource_id, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/api/image.py:251: in inspect_image
    return self._result(
../.local/lib/python3.12/site-packages/docker/api/client.py:281: in _result
    self._raise_for_status(response)
../.local/lib/python3.12/site-packages/docker/api/client.py:277: in _raise_for_status
    raise create_api_error_from_http_exception(e) from e
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

e = HTTPError('404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json')

    def create_api_error_from_http_exception(e):
        """
        Create a suitable APIError from requests.exceptions.HTTPError.
        """
        response = e.response
        try:
            explanation = response.json()['message']
        except ValueError:
            explanation = (response.text or '').strip()
        cls = APIError
        if response.status_code == 404:
            explanation_msg = (explanation or '').lower()
            if any(fragment in explanation_msg
                   for fragment in _image_not_found_explanation_fragments):
                cls = ImageNotFound
            else:
                cls = NotFound
>       raise cls(e, response=response, explanation=explanation) from e
E       docker.errors.ImageNotFound: 404 Client Error for http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json: Not Found ("No such image: wildfire-watch/gpio_trigger:test")

../.local/lib/python3.12/site-packages/docker/errors.py:39: ImageNotFound

During handling of the above exception, another exception occurred:

self = <test_integration_e2e.TestE2EIntegration object at 0x7f9acff04710>

    @pytest.fixture(scope="class")
    def integration_setup(self):
        """Setup integration test environment"""
        setup = IntegrationTestSetup()
>       containers = setup.setup_all_services()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration_e2e.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration_setup.py:204: in setup_all_services
    trigger = self.setup_gpio_trigger()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/integration_setup.py:158: in setup_gpio_trigger
    image, logs = self.docker_client.images.build(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <docker.models.images.ImageCollection object at 0x7f9acfd8fc50>
kwargs = {'buildargs': {'PLATFORM': 'linux/amd64'}, 'path': '/home/seth/wildfire-watch/gpio_trigger', 'rm': True, 'tag': 'wildfire-watch/gpio_trigger:test'}
resp = <generator object APIClient._stream_helper at 0x7f9acfd75540>
last_event = {'stream': '\n'}, image_id = None
result_stream = <itertools._tee object at 0x7f9acfe15fc0>
internal_stream = <itertools._tee object at 0x7f9acfe15c40>
chunk = {'error': 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does no... 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist'}}
match = None

    def build(self, **kwargs):
        """
        Build an image and return it. Similar to the ``docker build``
        command. Either ``path`` or ``fileobj`` must be set.
    
        If you already have a tar file for the Docker build context (including
        a Dockerfile), pass a readable file-like object to ``fileobj``
        and also pass ``custom_context=True``. If the stream is also
        compressed, set ``encoding`` to the correct value (e.g ``gzip``).
    
        If you want to get the raw output of the build, use the
        :py:meth:`~docker.api.build.BuildApiMixin.build` method in the
        low-level API.
    
        Args:
            path (str): Path to the directory containing the Dockerfile
            fileobj: A file object to use as the Dockerfile. (Or a file-like
                object)
            tag (str): A tag to add to the final image
            quiet (bool): Whether to return the status
            nocache (bool): Don't use the cache when set to ``True``
            rm (bool): Remove intermediate containers. The ``docker build``
                command now defaults to ``--rm=true``, but we have kept the old
                default of `False` to preserve backward compatibility
            timeout (int): HTTP timeout
            custom_context (bool): Optional if using ``fileobj``
            encoding (str): The encoding for a stream. Set to ``gzip`` for
                compressing
            pull (bool): Downloads any updates to the FROM image in Dockerfiles
            forcerm (bool): Always remove intermediate containers, even after
                unsuccessful builds
            dockerfile (str): path within the build context to the Dockerfile
            buildargs (dict): A dictionary of build arguments
            container_limits (dict): A dictionary of limits applied to each
                container created by the build process. Valid keys:
    
                - memory (int): set memory limit for build
                - memswap (int): Total memory (memory + swap), -1 to disable
                    swap
                - cpushares (int): CPU shares (relative weight)
                - cpusetcpus (str): CPUs in which to allow execution, e.g.,
                    ``"0-3"``, ``"0,1"``
            shmsize (int): Size of `/dev/shm` in bytes. The size must be
                greater than 0. If omitted the system uses 64MB
            labels (dict): A dictionary of labels to set on the image
            cache_from (list): A list of images used for build cache
                resolution
            target (str): Name of the build-stage to build in a multi-stage
                Dockerfile
            network_mode (str): networking mode for the run commands during
                build
            squash (bool): Squash the resulting images layers into a
                single layer.
            extra_hosts (dict): Extra hosts to add to /etc/hosts in building
                containers, as a mapping of hostname to IP address.
            platform (str): Platform in the format ``os[/arch[/variant]]``.
            isolation (str): Isolation technology used during build.
                Default: `None`.
            use_config_proxy (bool): If ``True``, and if the docker client
                configuration file (``~/.docker/config.json`` by default)
                contains a proxy configuration, the corresponding environment
                variables will be set in the container being built.
    
        Returns:
            (tuple): The first item is the :py:class:`Image` object for the
                image that was built. The second item is a generator of the
                build logs as JSON-decoded objects.
    
        Raises:
            :py:class:`docker.errors.BuildError`
                If there is an error during the build.
            :py:class:`docker.errors.APIError`
                If the server returns any other error.
            ``TypeError``
                If neither ``path`` nor ``fileobj`` is specified.
        """
        resp = self.client.api.build(**kwargs)
        if isinstance(resp, str):
            return self.get(resp)
        last_event = None
        image_id = None
        result_stream, internal_stream = itertools.tee(json_stream(resp))
        for chunk in internal_stream:
            if 'error' in chunk:
>               raise BuildError(chunk['error'], result_stream)
E               docker.errors.BuildError: COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist

../.local/lib/python3.12/site-packages/docker/models/images.py:304: BuildError
---------------------------- Captured stdout setup -----------------------------
Setting up integration test environment...
✓ MQTT broker: mqtt-broker-test
✓ Camera detector: camera-detector-test
✓ Fire consensus: fire-consensus-test
____ ERROR at setup of TestE2EIntegration.test_camera_discovery_to_frigate _____

self = <docker.api.client.APIClient object at 0x7f9acfd8e480>
response = <Response [404]>

    def _raise_for_status(self, response):
        """Raises stored :class:`APIError`, if one occurred."""
        try:
>           response.raise_for_status()

../.local/lib/python3.12/site-packages/docker/api/client.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ""
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode("utf-8")
            except UnicodeDecodeError:
                reason = self.reason.decode("iso-8859-1")
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = (
                f"{self.status_code} Client Error: {reason} for url: {self.url}"
            )
    
        elif 500 <= self.status_code < 600:
            http_error_msg = (
                f"{self.status_code} Server Error: {reason} for url: {self.url}"
            )
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json

/usr/local/lib/python3.12/dist-packages/requests/models.py:1024: HTTPError

The above exception was the direct cause of the following exception:

self = <integration_setup.IntegrationTestSetup object at 0x7f9acfd8e420>

    def setup_gpio_trigger(self):
        """Create GPIO trigger container"""
        mqtt_container = self.setup_mqtt_broker()
    
        try:
>           image = self.docker_client.images.get("wildfire-watch/gpio_trigger:test")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration_setup.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.local/lib/python3.12/site-packages/docker/models/images.py:333: in get
    return self.prepare_model(self.client.api.inspect_image(name))
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/utils/decorators.py:19: in wrapped
    return f(self, resource_id, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/api/image.py:251: in inspect_image
    return self._result(
../.local/lib/python3.12/site-packages/docker/api/client.py:281: in _result
    self._raise_for_status(response)
../.local/lib/python3.12/site-packages/docker/api/client.py:277: in _raise_for_status
    raise create_api_error_from_http_exception(e) from e
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

e = HTTPError('404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json')

    def create_api_error_from_http_exception(e):
        """
        Create a suitable APIError from requests.exceptions.HTTPError.
        """
        response = e.response
        try:
            explanation = response.json()['message']
        except ValueError:
            explanation = (response.text or '').strip()
        cls = APIError
        if response.status_code == 404:
            explanation_msg = (explanation or '').lower()
            if any(fragment in explanation_msg
                   for fragment in _image_not_found_explanation_fragments):
                cls = ImageNotFound
            else:
                cls = NotFound
>       raise cls(e, response=response, explanation=explanation) from e
E       docker.errors.ImageNotFound: 404 Client Error for http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json: Not Found ("No such image: wildfire-watch/gpio_trigger:test")

../.local/lib/python3.12/site-packages/docker/errors.py:39: ImageNotFound

During handling of the above exception, another exception occurred:

self = <test_integration_e2e.TestE2EIntegration object at 0x7f9acff04710>

    @pytest.fixture(scope="class")
    def integration_setup(self):
        """Setup integration test environment"""
        setup = IntegrationTestSetup()
>       containers = setup.setup_all_services()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration_e2e.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration_setup.py:204: in setup_all_services
    trigger = self.setup_gpio_trigger()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/integration_setup.py:158: in setup_gpio_trigger
    image, logs = self.docker_client.images.build(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <docker.models.images.ImageCollection object at 0x7f9acfd8fc50>
kwargs = {'buildargs': {'PLATFORM': 'linux/amd64'}, 'path': '/home/seth/wildfire-watch/gpio_trigger', 'rm': True, 'tag': 'wildfire-watch/gpio_trigger:test'}
resp = <generator object APIClient._stream_helper at 0x7f9acfd75540>
last_event = {'stream': '\n'}, image_id = None
result_stream = <itertools._tee object at 0x7f9acfe15fc0>
internal_stream = <itertools._tee object at 0x7f9acfe15c40>
chunk = {'error': 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does no... 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist'}}
match = None

    def build(self, **kwargs):
        """
        Build an image and return it. Similar to the ``docker build``
        command. Either ``path`` or ``fileobj`` must be set.
    
        If you already have a tar file for the Docker build context (including
        a Dockerfile), pass a readable file-like object to ``fileobj``
        and also pass ``custom_context=True``. If the stream is also
        compressed, set ``encoding`` to the correct value (e.g ``gzip``).
    
        If you want to get the raw output of the build, use the
        :py:meth:`~docker.api.build.BuildApiMixin.build` method in the
        low-level API.
    
        Args:
            path (str): Path to the directory containing the Dockerfile
            fileobj: A file object to use as the Dockerfile. (Or a file-like
                object)
            tag (str): A tag to add to the final image
            quiet (bool): Whether to return the status
            nocache (bool): Don't use the cache when set to ``True``
            rm (bool): Remove intermediate containers. The ``docker build``
                command now defaults to ``--rm=true``, but we have kept the old
                default of `False` to preserve backward compatibility
            timeout (int): HTTP timeout
            custom_context (bool): Optional if using ``fileobj``
            encoding (str): The encoding for a stream. Set to ``gzip`` for
                compressing
            pull (bool): Downloads any updates to the FROM image in Dockerfiles
            forcerm (bool): Always remove intermediate containers, even after
                unsuccessful builds
            dockerfile (str): path within the build context to the Dockerfile
            buildargs (dict): A dictionary of build arguments
            container_limits (dict): A dictionary of limits applied to each
                container created by the build process. Valid keys:
    
                - memory (int): set memory limit for build
                - memswap (int): Total memory (memory + swap), -1 to disable
                    swap
                - cpushares (int): CPU shares (relative weight)
                - cpusetcpus (str): CPUs in which to allow execution, e.g.,
                    ``"0-3"``, ``"0,1"``
            shmsize (int): Size of `/dev/shm` in bytes. The size must be
                greater than 0. If omitted the system uses 64MB
            labels (dict): A dictionary of labels to set on the image
            cache_from (list): A list of images used for build cache
                resolution
            target (str): Name of the build-stage to build in a multi-stage
                Dockerfile
            network_mode (str): networking mode for the run commands during
                build
            squash (bool): Squash the resulting images layers into a
                single layer.
            extra_hosts (dict): Extra hosts to add to /etc/hosts in building
                containers, as a mapping of hostname to IP address.
            platform (str): Platform in the format ``os[/arch[/variant]]``.
            isolation (str): Isolation technology used during build.
                Default: `None`.
            use_config_proxy (bool): If ``True``, and if the docker client
                configuration file (``~/.docker/config.json`` by default)
                contains a proxy configuration, the corresponding environment
                variables will be set in the container being built.
    
        Returns:
            (tuple): The first item is the :py:class:`Image` object for the
                image that was built. The second item is a generator of the
                build logs as JSON-decoded objects.
    
        Raises:
            :py:class:`docker.errors.BuildError`
                If there is an error during the build.
            :py:class:`docker.errors.APIError`
                If the server returns any other error.
            ``TypeError``
                If neither ``path`` nor ``fileobj`` is specified.
        """
        resp = self.client.api.build(**kwargs)
        if isinstance(resp, str):
            return self.get(resp)
        last_event = None
        image_id = None
        result_stream, internal_stream = itertools.tee(json_stream(resp))
        for chunk in internal_stream:
            if 'error' in chunk:
>               raise BuildError(chunk['error'], result_stream)
E               docker.errors.BuildError: COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist

../.local/lib/python3.12/site-packages/docker/models/images.py:304: BuildError
_ ERROR at setup of TestE2EIntegration.test_fire_detection_to_pump_activation __

self = <docker.api.client.APIClient object at 0x7f9acfd8e480>
response = <Response [404]>

    def _raise_for_status(self, response):
        """Raises stored :class:`APIError`, if one occurred."""
        try:
>           response.raise_for_status()

../.local/lib/python3.12/site-packages/docker/api/client.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ""
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode("utf-8")
            except UnicodeDecodeError:
                reason = self.reason.decode("iso-8859-1")
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = (
                f"{self.status_code} Client Error: {reason} for url: {self.url}"
            )
    
        elif 500 <= self.status_code < 600:
            http_error_msg = (
                f"{self.status_code} Server Error: {reason} for url: {self.url}"
            )
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json

/usr/local/lib/python3.12/dist-packages/requests/models.py:1024: HTTPError

The above exception was the direct cause of the following exception:

self = <integration_setup.IntegrationTestSetup object at 0x7f9acfd8e420>

    def setup_gpio_trigger(self):
        """Create GPIO trigger container"""
        mqtt_container = self.setup_mqtt_broker()
    
        try:
>           image = self.docker_client.images.get("wildfire-watch/gpio_trigger:test")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration_setup.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.local/lib/python3.12/site-packages/docker/models/images.py:333: in get
    return self.prepare_model(self.client.api.inspect_image(name))
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/utils/decorators.py:19: in wrapped
    return f(self, resource_id, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/api/image.py:251: in inspect_image
    return self._result(
../.local/lib/python3.12/site-packages/docker/api/client.py:281: in _result
    self._raise_for_status(response)
../.local/lib/python3.12/site-packages/docker/api/client.py:277: in _raise_for_status
    raise create_api_error_from_http_exception(e) from e
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

e = HTTPError('404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json')

    def create_api_error_from_http_exception(e):
        """
        Create a suitable APIError from requests.exceptions.HTTPError.
        """
        response = e.response
        try:
            explanation = response.json()['message']
        except ValueError:
            explanation = (response.text or '').strip()
        cls = APIError
        if response.status_code == 404:
            explanation_msg = (explanation or '').lower()
            if any(fragment in explanation_msg
                   for fragment in _image_not_found_explanation_fragments):
                cls = ImageNotFound
            else:
                cls = NotFound
>       raise cls(e, response=response, explanation=explanation) from e
E       docker.errors.ImageNotFound: 404 Client Error for http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json: Not Found ("No such image: wildfire-watch/gpio_trigger:test")

../.local/lib/python3.12/site-packages/docker/errors.py:39: ImageNotFound

During handling of the above exception, another exception occurred:

self = <test_integration_e2e.TestE2EIntegration object at 0x7f9acff04710>

    @pytest.fixture(scope="class")
    def integration_setup(self):
        """Setup integration test environment"""
        setup = IntegrationTestSetup()
>       containers = setup.setup_all_services()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration_e2e.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration_setup.py:204: in setup_all_services
    trigger = self.setup_gpio_trigger()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/integration_setup.py:158: in setup_gpio_trigger
    image, logs = self.docker_client.images.build(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <docker.models.images.ImageCollection object at 0x7f9acfd8fc50>
kwargs = {'buildargs': {'PLATFORM': 'linux/amd64'}, 'path': '/home/seth/wildfire-watch/gpio_trigger', 'rm': True, 'tag': 'wildfire-watch/gpio_trigger:test'}
resp = <generator object APIClient._stream_helper at 0x7f9acfd75540>
last_event = {'stream': '\n'}, image_id = None
result_stream = <itertools._tee object at 0x7f9acfe15fc0>
internal_stream = <itertools._tee object at 0x7f9acfe15c40>
chunk = {'error': 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does no... 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist'}}
match = None

    def build(self, **kwargs):
        """
        Build an image and return it. Similar to the ``docker build``
        command. Either ``path`` or ``fileobj`` must be set.
    
        If you already have a tar file for the Docker build context (including
        a Dockerfile), pass a readable file-like object to ``fileobj``
        and also pass ``custom_context=True``. If the stream is also
        compressed, set ``encoding`` to the correct value (e.g ``gzip``).
    
        If you want to get the raw output of the build, use the
        :py:meth:`~docker.api.build.BuildApiMixin.build` method in the
        low-level API.
    
        Args:
            path (str): Path to the directory containing the Dockerfile
            fileobj: A file object to use as the Dockerfile. (Or a file-like
                object)
            tag (str): A tag to add to the final image
            quiet (bool): Whether to return the status
            nocache (bool): Don't use the cache when set to ``True``
            rm (bool): Remove intermediate containers. The ``docker build``
                command now defaults to ``--rm=true``, but we have kept the old
                default of `False` to preserve backward compatibility
            timeout (int): HTTP timeout
            custom_context (bool): Optional if using ``fileobj``
            encoding (str): The encoding for a stream. Set to ``gzip`` for
                compressing
            pull (bool): Downloads any updates to the FROM image in Dockerfiles
            forcerm (bool): Always remove intermediate containers, even after
                unsuccessful builds
            dockerfile (str): path within the build context to the Dockerfile
            buildargs (dict): A dictionary of build arguments
            container_limits (dict): A dictionary of limits applied to each
                container created by the build process. Valid keys:
    
                - memory (int): set memory limit for build
                - memswap (int): Total memory (memory + swap), -1 to disable
                    swap
                - cpushares (int): CPU shares (relative weight)
                - cpusetcpus (str): CPUs in which to allow execution, e.g.,
                    ``"0-3"``, ``"0,1"``
            shmsize (int): Size of `/dev/shm` in bytes. The size must be
                greater than 0. If omitted the system uses 64MB
            labels (dict): A dictionary of labels to set on the image
            cache_from (list): A list of images used for build cache
                resolution
            target (str): Name of the build-stage to build in a multi-stage
                Dockerfile
            network_mode (str): networking mode for the run commands during
                build
            squash (bool): Squash the resulting images layers into a
                single layer.
            extra_hosts (dict): Extra hosts to add to /etc/hosts in building
                containers, as a mapping of hostname to IP address.
            platform (str): Platform in the format ``os[/arch[/variant]]``.
            isolation (str): Isolation technology used during build.
                Default: `None`.
            use_config_proxy (bool): If ``True``, and if the docker client
                configuration file (``~/.docker/config.json`` by default)
                contains a proxy configuration, the corresponding environment
                variables will be set in the container being built.
    
        Returns:
            (tuple): The first item is the :py:class:`Image` object for the
                image that was built. The second item is a generator of the
                build logs as JSON-decoded objects.
    
        Raises:
            :py:class:`docker.errors.BuildError`
                If there is an error during the build.
            :py:class:`docker.errors.APIError`
                If the server returns any other error.
            ``TypeError``
                If neither ``path`` nor ``fileobj`` is specified.
        """
        resp = self.client.api.build(**kwargs)
        if isinstance(resp, str):
            return self.get(resp)
        last_event = None
        image_id = None
        result_stream, internal_stream = itertools.tee(json_stream(resp))
        for chunk in internal_stream:
            if 'error' in chunk:
>               raise BuildError(chunk['error'], result_stream)
E               docker.errors.BuildError: COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist

../.local/lib/python3.12/site-packages/docker/models/images.py:304: BuildError
_________ ERROR at setup of TestE2EIntegration.test_health_monitoring __________

self = <docker.api.client.APIClient object at 0x7f9acfd8e480>
response = <Response [404]>

    def _raise_for_status(self, response):
        """Raises stored :class:`APIError`, if one occurred."""
        try:
>           response.raise_for_status()

../.local/lib/python3.12/site-packages/docker/api/client.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ""
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode("utf-8")
            except UnicodeDecodeError:
                reason = self.reason.decode("iso-8859-1")
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = (
                f"{self.status_code} Client Error: {reason} for url: {self.url}"
            )
    
        elif 500 <= self.status_code < 600:
            http_error_msg = (
                f"{self.status_code} Server Error: {reason} for url: {self.url}"
            )
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json

/usr/local/lib/python3.12/dist-packages/requests/models.py:1024: HTTPError

The above exception was the direct cause of the following exception:

self = <integration_setup.IntegrationTestSetup object at 0x7f9acfd8e420>

    def setup_gpio_trigger(self):
        """Create GPIO trigger container"""
        mqtt_container = self.setup_mqtt_broker()
    
        try:
>           image = self.docker_client.images.get("wildfire-watch/gpio_trigger:test")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration_setup.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.local/lib/python3.12/site-packages/docker/models/images.py:333: in get
    return self.prepare_model(self.client.api.inspect_image(name))
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/utils/decorators.py:19: in wrapped
    return f(self, resource_id, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/api/image.py:251: in inspect_image
    return self._result(
../.local/lib/python3.12/site-packages/docker/api/client.py:281: in _result
    self._raise_for_status(response)
../.local/lib/python3.12/site-packages/docker/api/client.py:277: in _raise_for_status
    raise create_api_error_from_http_exception(e) from e
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

e = HTTPError('404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json')

    def create_api_error_from_http_exception(e):
        """
        Create a suitable APIError from requests.exceptions.HTTPError.
        """
        response = e.response
        try:
            explanation = response.json()['message']
        except ValueError:
            explanation = (response.text or '').strip()
        cls = APIError
        if response.status_code == 404:
            explanation_msg = (explanation or '').lower()
            if any(fragment in explanation_msg
                   for fragment in _image_not_found_explanation_fragments):
                cls = ImageNotFound
            else:
                cls = NotFound
>       raise cls(e, response=response, explanation=explanation) from e
E       docker.errors.ImageNotFound: 404 Client Error for http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json: Not Found ("No such image: wildfire-watch/gpio_trigger:test")

../.local/lib/python3.12/site-packages/docker/errors.py:39: ImageNotFound

During handling of the above exception, another exception occurred:

self = <test_integration_e2e.TestE2EIntegration object at 0x7f9acff04710>

    @pytest.fixture(scope="class")
    def integration_setup(self):
        """Setup integration test environment"""
        setup = IntegrationTestSetup()
>       containers = setup.setup_all_services()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration_e2e.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration_setup.py:204: in setup_all_services
    trigger = self.setup_gpio_trigger()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/integration_setup.py:158: in setup_gpio_trigger
    image, logs = self.docker_client.images.build(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <docker.models.images.ImageCollection object at 0x7f9acfd8fc50>
kwargs = {'buildargs': {'PLATFORM': 'linux/amd64'}, 'path': '/home/seth/wildfire-watch/gpio_trigger', 'rm': True, 'tag': 'wildfire-watch/gpio_trigger:test'}
resp = <generator object APIClient._stream_helper at 0x7f9acfd75540>
last_event = {'stream': '\n'}, image_id = None
result_stream = <itertools._tee object at 0x7f9acfe15fc0>
internal_stream = <itertools._tee object at 0x7f9acfe15c40>
chunk = {'error': 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does no... 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist'}}
match = None

    def build(self, **kwargs):
        """
        Build an image and return it. Similar to the ``docker build``
        command. Either ``path`` or ``fileobj`` must be set.
    
        If you already have a tar file for the Docker build context (including
        a Dockerfile), pass a readable file-like object to ``fileobj``
        and also pass ``custom_context=True``. If the stream is also
        compressed, set ``encoding`` to the correct value (e.g ``gzip``).
    
        If you want to get the raw output of the build, use the
        :py:meth:`~docker.api.build.BuildApiMixin.build` method in the
        low-level API.
    
        Args:
            path (str): Path to the directory containing the Dockerfile
            fileobj: A file object to use as the Dockerfile. (Or a file-like
                object)
            tag (str): A tag to add to the final image
            quiet (bool): Whether to return the status
            nocache (bool): Don't use the cache when set to ``True``
            rm (bool): Remove intermediate containers. The ``docker build``
                command now defaults to ``--rm=true``, but we have kept the old
                default of `False` to preserve backward compatibility
            timeout (int): HTTP timeout
            custom_context (bool): Optional if using ``fileobj``
            encoding (str): The encoding for a stream. Set to ``gzip`` for
                compressing
            pull (bool): Downloads any updates to the FROM image in Dockerfiles
            forcerm (bool): Always remove intermediate containers, even after
                unsuccessful builds
            dockerfile (str): path within the build context to the Dockerfile
            buildargs (dict): A dictionary of build arguments
            container_limits (dict): A dictionary of limits applied to each
                container created by the build process. Valid keys:
    
                - memory (int): set memory limit for build
                - memswap (int): Total memory (memory + swap), -1 to disable
                    swap
                - cpushares (int): CPU shares (relative weight)
                - cpusetcpus (str): CPUs in which to allow execution, e.g.,
                    ``"0-3"``, ``"0,1"``
            shmsize (int): Size of `/dev/shm` in bytes. The size must be
                greater than 0. If omitted the system uses 64MB
            labels (dict): A dictionary of labels to set on the image
            cache_from (list): A list of images used for build cache
                resolution
            target (str): Name of the build-stage to build in a multi-stage
                Dockerfile
            network_mode (str): networking mode for the run commands during
                build
            squash (bool): Squash the resulting images layers into a
                single layer.
            extra_hosts (dict): Extra hosts to add to /etc/hosts in building
                containers, as a mapping of hostname to IP address.
            platform (str): Platform in the format ``os[/arch[/variant]]``.
            isolation (str): Isolation technology used during build.
                Default: `None`.
            use_config_proxy (bool): If ``True``, and if the docker client
                configuration file (``~/.docker/config.json`` by default)
                contains a proxy configuration, the corresponding environment
                variables will be set in the container being built.
    
        Returns:
            (tuple): The first item is the :py:class:`Image` object for the
                image that was built. The second item is a generator of the
                build logs as JSON-decoded objects.
    
        Raises:
            :py:class:`docker.errors.BuildError`
                If there is an error during the build.
            :py:class:`docker.errors.APIError`
                If the server returns any other error.
            ``TypeError``
                If neither ``path`` nor ``fileobj`` is specified.
        """
        resp = self.client.api.build(**kwargs)
        if isinstance(resp, str):
            return self.get(resp)
        last_event = None
        image_id = None
        result_stream, internal_stream = itertools.tee(json_stream(resp))
        for chunk in internal_stream:
            if 'error' in chunk:
>               raise BuildError(chunk['error'], result_stream)
E               docker.errors.BuildError: COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist

../.local/lib/python3.12/site-packages/docker/models/images.py:304: BuildError
___________ ERROR at setup of TestE2EIntegration.test_error_recovery ___________

self = <docker.api.client.APIClient object at 0x7f9acfd8e480>
response = <Response [404]>

    def _raise_for_status(self, response):
        """Raises stored :class:`APIError`, if one occurred."""
        try:
>           response.raise_for_status()

../.local/lib/python3.12/site-packages/docker/api/client.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ""
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode("utf-8")
            except UnicodeDecodeError:
                reason = self.reason.decode("iso-8859-1")
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = (
                f"{self.status_code} Client Error: {reason} for url: {self.url}"
            )
    
        elif 500 <= self.status_code < 600:
            http_error_msg = (
                f"{self.status_code} Server Error: {reason} for url: {self.url}"
            )
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json

/usr/local/lib/python3.12/dist-packages/requests/models.py:1024: HTTPError

The above exception was the direct cause of the following exception:

self = <integration_setup.IntegrationTestSetup object at 0x7f9acfd8e420>

    def setup_gpio_trigger(self):
        """Create GPIO trigger container"""
        mqtt_container = self.setup_mqtt_broker()
    
        try:
>           image = self.docker_client.images.get("wildfire-watch/gpio_trigger:test")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration_setup.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../.local/lib/python3.12/site-packages/docker/models/images.py:333: in get
    return self.prepare_model(self.client.api.inspect_image(name))
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/utils/decorators.py:19: in wrapped
    return f(self, resource_id, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../.local/lib/python3.12/site-packages/docker/api/image.py:251: in inspect_image
    return self._result(
../.local/lib/python3.12/site-packages/docker/api/client.py:281: in _result
    self._raise_for_status(response)
../.local/lib/python3.12/site-packages/docker/api/client.py:277: in _raise_for_status
    raise create_api_error_from_http_exception(e) from e
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

e = HTTPError('404 Client Error: Not Found for url: http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json')

    def create_api_error_from_http_exception(e):
        """
        Create a suitable APIError from requests.exceptions.HTTPError.
        """
        response = e.response
        try:
            explanation = response.json()['message']
        except ValueError:
            explanation = (response.text or '').strip()
        cls = APIError
        if response.status_code == 404:
            explanation_msg = (explanation or '').lower()
            if any(fragment in explanation_msg
                   for fragment in _image_not_found_explanation_fragments):
                cls = ImageNotFound
            else:
                cls = NotFound
>       raise cls(e, response=response, explanation=explanation) from e
E       docker.errors.ImageNotFound: 404 Client Error for http+docker://localhost/v1.49/images/wildfire-watch/gpio_trigger:test/json: Not Found ("No such image: wildfire-watch/gpio_trigger:test")

../.local/lib/python3.12/site-packages/docker/errors.py:39: ImageNotFound

During handling of the above exception, another exception occurred:

self = <test_integration_e2e.TestE2EIntegration object at 0x7f9acff04710>

    @pytest.fixture(scope="class")
    def integration_setup(self):
        """Setup integration test environment"""
        setup = IntegrationTestSetup()
>       containers = setup.setup_all_services()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration_e2e.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration_setup.py:204: in setup_all_services
    trigger = self.setup_gpio_trigger()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/integration_setup.py:158: in setup_gpio_trigger
    image, logs = self.docker_client.images.build(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <docker.models.images.ImageCollection object at 0x7f9acfd8fc50>
kwargs = {'buildargs': {'PLATFORM': 'linux/amd64'}, 'path': '/home/seth/wildfire-watch/gpio_trigger', 'rm': True, 'tag': 'wildfire-watch/gpio_trigger:test'}
resp = <generator object APIClient._stream_helper at 0x7f9acfd75540>
last_event = {'stream': '\n'}, image_id = None
result_stream = <itertools._tee object at 0x7f9acfe15fc0>
internal_stream = <itertools._tee object at 0x7f9acfe15c40>
chunk = {'error': 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does no... 'COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist'}}
match = None

    def build(self, **kwargs):
        """
        Build an image and return it. Similar to the ``docker build``
        command. Either ``path`` or ``fileobj`` must be set.
    
        If you already have a tar file for the Docker build context (including
        a Dockerfile), pass a readable file-like object to ``fileobj``
        and also pass ``custom_context=True``. If the stream is also
        compressed, set ``encoding`` to the correct value (e.g ``gzip``).
    
        If you want to get the raw output of the build, use the
        :py:meth:`~docker.api.build.BuildApiMixin.build` method in the
        low-level API.
    
        Args:
            path (str): Path to the directory containing the Dockerfile
            fileobj: A file object to use as the Dockerfile. (Or a file-like
                object)
            tag (str): A tag to add to the final image
            quiet (bool): Whether to return the status
            nocache (bool): Don't use the cache when set to ``True``
            rm (bool): Remove intermediate containers. The ``docker build``
                command now defaults to ``--rm=true``, but we have kept the old
                default of `False` to preserve backward compatibility
            timeout (int): HTTP timeout
            custom_context (bool): Optional if using ``fileobj``
            encoding (str): The encoding for a stream. Set to ``gzip`` for
                compressing
            pull (bool): Downloads any updates to the FROM image in Dockerfiles
            forcerm (bool): Always remove intermediate containers, even after
                unsuccessful builds
            dockerfile (str): path within the build context to the Dockerfile
            buildargs (dict): A dictionary of build arguments
            container_limits (dict): A dictionary of limits applied to each
                container created by the build process. Valid keys:
    
                - memory (int): set memory limit for build
                - memswap (int): Total memory (memory + swap), -1 to disable
                    swap
                - cpushares (int): CPU shares (relative weight)
                - cpusetcpus (str): CPUs in which to allow execution, e.g.,
                    ``"0-3"``, ``"0,1"``
            shmsize (int): Size of `/dev/shm` in bytes. The size must be
                greater than 0. If omitted the system uses 64MB
            labels (dict): A dictionary of labels to set on the image
            cache_from (list): A list of images used for build cache
                resolution
            target (str): Name of the build-stage to build in a multi-stage
                Dockerfile
            network_mode (str): networking mode for the run commands during
                build
            squash (bool): Squash the resulting images layers into a
                single layer.
            extra_hosts (dict): Extra hosts to add to /etc/hosts in building
                containers, as a mapping of hostname to IP address.
            platform (str): Platform in the format ``os[/arch[/variant]]``.
            isolation (str): Isolation technology used during build.
                Default: `None`.
            use_config_proxy (bool): If ``True``, and if the docker client
                configuration file (``~/.docker/config.json`` by default)
                contains a proxy configuration, the corresponding environment
                variables will be set in the container being built.
    
        Returns:
            (tuple): The first item is the :py:class:`Image` object for the
                image that was built. The second item is a generator of the
                build logs as JSON-decoded objects.
    
        Raises:
            :py:class:`docker.errors.BuildError`
                If there is an error during the build.
            :py:class:`docker.errors.APIError`
                If the server returns any other error.
            ``TypeError``
                If neither ``path`` nor ``fileobj`` is specified.
        """
        resp = self.client.api.build(**kwargs)
        if isinstance(resp, str):
            return self.get(resp)
        last_event = None
        image_id = None
        result_stream, internal_stream = itertools.tee(json_stream(resp))
        for chunk in internal_stream:
            if 'error' in chunk:
>               raise BuildError(chunk['error'], result_stream)
E               docker.errors.BuildError: COPY failed: file not found in build context or excluded by .dockerignore: stat nsswitch.conf: file does not exist

../.local/lib/python3.12/site-packages/docker/models/images.py:304: BuildError
=============================== warnings summary ===============================
../../../usr/lib/python3/dist-packages/paramiko/pkey.py:59
  /usr/lib/python3/dist-packages/paramiko/pkey.py:59: CryptographyDeprecationWarning: TripleDES has been moved to cryptography.hazmat.decrepit.ciphers.algorithms.TripleDES and will be removed from cryptography.hazmat.primitives.ciphers.algorithms in 48.0.0.
    "cipher": algorithms.TripleDES,

../../../usr/lib/python3/dist-packages/paramiko/transport.py:220
  /usr/lib/python3/dist-packages/paramiko/transport.py:220: CryptographyDeprecationWarning: Blowfish has been moved to cryptography.hazmat.decrepit.ciphers.algorithms.Blowfish and will be removed from cryptography.hazmat.primitives.ciphers.algorithms in 45.0.0.
    "class": algorithms.Blowfish,

../../../usr/lib/python3/dist-packages/paramiko/transport.py:244
  /usr/lib/python3/dist-packages/paramiko/transport.py:244: CryptographyDeprecationWarning: TripleDES has been moved to cryptography.hazmat.decrepit.ciphers.algorithms.TripleDES and will be removed from cryptography.hazmat.primitives.ciphers.algorithms in 48.0.0.
    "class": algorithms.TripleDES,

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/test_integration_e2e.py::TestE2EIntegration::test_service_startup_order
ERROR tests/test_integration_e2e.py::TestE2EIntegration::test_camera_discovery_to_frigate
ERROR tests/test_integration_e2e.py::TestE2EIntegration::test_fire_detection_to_pump_activation
ERROR tests/test_integration_e2e.py::TestE2EIntegration::test_health_monitoring
ERROR tests/test_integration_e2e.py::TestE2EIntegration::test_error_recovery
======================== 3 warnings, 5 errors in 19.83s ========================
