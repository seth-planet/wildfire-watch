# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Wildfire Watch is an automated fire detection and suppression system that runs on edge devices. It uses AI-powered cameras with multi-camera consensus to detect fires and automatically activates sprinkler systems via GPIO control.

## Development Commands

### Build and Deployment
```bash
# Generate secure certificates (required for production)
./scripts/generate_certs.sh custom

# Development with hot reload
docker-compose --env-file .env.dev up

# Full deployment
docker-compose up -d

# Multi-platform builds
./scripts/build_multiplatform.sh

# Balena deployment
balena push wildfire-watch
```

### Testing
```bash
# Run all tests
python3.12 -m pytest tests/ -v

# Specific test files
python3.12 -m pytest tests/test_consensus.py
python3.12 -m pytest tests/test_integration_e2e.py

# Hardware integration tests (requires actual hardware)
python3.12 -m pytest tests/test_hardware_integration.py
```

### Python Version
This project requires Python 3.12. All commands should use `python3.12` and `pip3.12`.

### Service Management
```bash
# Individual services
docker-compose up mqtt-broker camera-detector
docker-compose logs -f fire-consensus

# Service shell access
docker exec -it camera-detector /bin/bash

# Enable debug logging
LOG_LEVEL=DEBUG docker-compose up
```

## Architecture Overview

### Microservices Communication
All services communicate via MQTT broker with the following data flow:

1. **Camera Detector** → Discovers IP cameras, publishes to `cameras/discovered`
2. **Security NVR (Frigate)** → AI detection, publishes to `frigate/*/fire` and `frigate/*/smoke`
3. **Fire Consensus** → Validates detections, publishes to `trigger/fire_detected`
4. **GPIO Trigger** → Controls pump hardware, publishes to `gpio/status`
5. **Telemetry** → Health monitoring, publishes to `telemetry/*`

### Service Dependencies
```
mqtt_broker (core)
├── camera_detector (needs MQTT)
├── security_nvr (needs MQTT + camera config)
├── fire_consensus (needs MQTT + camera data)
├── gpio_trigger (needs MQTT + consensus)
└── cam_telemetry (needs MQTT)
```

### Key Configuration Files
- `docker-compose.yml` - Service orchestration with healthchecks and dependencies
- `.env` - Environment variables for all services
- `certs/` - TLS certificates (generated by `./scripts/generate_certs.sh`)
- `frigate_config/config.yml` - Dynamically generated by camera_detector

## Development Patterns

### Adding New Camera Support
1. Modify `camera_detector/detect.py` discovery methods
2. Update camera credential handling in environment variables
3. Test RTSP stream validation
4. Ensure MAC address tracking works for persistent identification

### AI Model Integration
- Models stored in `converted_models/` with conversion script
- Supports Coral TPU (.tflite), Hailo (.hef), ONNX, TensorRT formats
- Update `security_nvr/nvr_base_config.yml` for new models
- Performance benchmarking required for each accelerator type

### GPIO Safety Systems
- All pump control in `gpio_trigger/trigger.py` uses state machine pattern
- Maximum runtime protection (default 30 minutes)
- Automatic refill calculation based on runtime
- Hardware simulation mode for development on non-Pi systems

### Multi-Camera Consensus Logic
- Located in `fire_consensus/consensus.py`
- Configurable threshold (CONSENSUS_THRESHOLD environment variable)
- Time-based confidence weighting
- Cooldown periods to prevent rapid re-triggering

## Hardware Abstraction

### AI Accelerator Support
- Auto-detection via `FRIGATE_DETECTOR=auto`
- Platform-specific device mappings in docker-compose.yml
- Performance targets: Coral (15-20ms), Hailo (10-25ms), GPU (8-12ms)

### GPIO Simulation
- Automatically enabled on non-Raspberry Pi systems
- Override with `GPIO_SIMULATION=true/false`
- All pin assignments configurable via environment variables

## Security Architecture

### Certificate Management
- Production requires running `./scripts/generate_certs.sh custom`
- Default certificates are intentionally insecure for development
- TLS enabled via `MQTT_TLS=true` environment variable

### Camera Credentials
- Supports multiple credential sets: `CAMERA_CREDENTIALS=admin:password,admin:12345`
- Automatic credential testing during discovery
- MAC address tracking prevents IP-based spoofing

## Testing Strategy

### Unit Tests (`tests/`)
- `test_consensus.py` - Multi-camera validation logic
- `test_detect.py` - Camera discovery and RTSP validation
- `test_trigger.py` - GPIO state machine and safety systems
- `test_telemetry.py` - Health monitoring

### Integration Tests
- `test_integration_e2e.py` - Full system workflow
- `test_hardware_integration.py` - Requires physical hardware
- `test_model_converter.py` - AI model format conversion

### Development Testing
- Use `GPIO_SIMULATION=true` for pump control testing
- Mock MQTT broker available for unit tests
- Camera discovery can be tested with fake RTSP streams

## Common Environment Variables

### Core Settings
- `CONSENSUS_THRESHOLD=2` - Cameras required for fire trigger
- `MIN_CONFIDENCE=0.7` - AI detection confidence threshold
- `MAX_ENGINE_RUNTIME=1800` - Safety limit in seconds
- `FRIGATE_DETECTOR=auto` - AI accelerator selection

### Development Settings
- `LOG_LEVEL=DEBUG` - Verbose logging
- `GPIO_SIMULATION=true` - Safe testing without hardware
- `DISCOVERY_INTERVAL=300` - Camera discovery frequency

## Deployment Considerations

### Balena Cloud
- Fleet management for multiple edge devices
- Environment variables managed via Balena dashboard
- Automatic updates and rollback support

### Resource Requirements
- Minimum 4GB RAM for Frigate + AI detection
- 32GB+ storage for video retention
- USB 3.0 for Coral TPU, PCIe for Hailo
- GPIO access required for pump control

### Network Architecture
- Cameras discovered via ONVIF, mDNS, port scanning
- MQTT broker creates isolated network (192.168.100.0/24)
- Frigate UI accessible on port 5000
- TLS encryption for production MQTT (port 8883)